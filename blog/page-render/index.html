<!doctype html>
<html lang="en" dir="ltr" class="blog-wrapper blog-post-page plugin-blog plugin-id-default">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-rc.1">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="My Site RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="My Site Atom Feed">



<link rel="search" type="application/opensearchdescription+xml" title="My Site" href="/opensearch.xml"><title data-rh="true">浏览器渲染页面 | My Site</title><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://zeffon.github.io/blog/page-render"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docusaurus_tag" content="default"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docsearch:docusaurus_tag" content="default"><meta data-rh="true" property="og:title" content="浏览器渲染页面 | My Site"><meta data-rh="true" name="description" content="作为前端开发，更多的都是在于浏览器打交道，对于一个页面是如何渲染出来，那么我们就需要很了解浏览器的渲染机制。而在了解浏览器的渲染机制前，我们需要了解浏览器的内部结构是怎样的。"><meta data-rh="true" property="og:description" content="作为前端开发，更多的都是在于浏览器打交道，对于一个页面是如何渲染出来，那么我们就需要很了解浏览器的渲染机制。而在了解浏览器的渲染机制前，我们需要了解浏览器的内部结构是怎样的。"><meta data-rh="true" property="og:type" content="article"><meta data-rh="true" property="article:published_time" content="2022-01-29T15:11:00.000Z"><meta data-rh="true" property="article:author" content="https://github.com/zeffon"><meta data-rh="true" property="article:tag" content="js"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://zeffon.github.io/blog/page-render"><link data-rh="true" rel="alternate" href="https://zeffon.github.io/blog/page-render" hreflang="en"><link data-rh="true" rel="alternate" href="https://zeffon.github.io/blog/page-render" hreflang="x-default"><link data-rh="true" rel="preconnect" href="https://1A7I0HQZDA-dsn.algolia.net" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/styles.0f34d59d.css">
<link rel="preload" href="/assets/js/runtime~main.77cd9461.js" as="script">
<link rel="preload" href="/assets/js/main.d08d51d4.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_fXgn">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">首页</b></a><a class="navbar__item navbar__link" href="/docs/intro">文档</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/blog">博客</a></div><div class="navbar__items navbar__items--right"><a href="https://www.yuque.com/zeffon/blog" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">语雀<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><a href="https://github.com/zeffon" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"></span></button></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper mainWrapper_z2l0"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="Blog recent posts navigation"><div class="sidebarItemTitle_pO2u margin-bottom--md">Recent posts</div><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/koa-web">使用 TypeScript 构建 Koa2 RESTful API 最佳的脚手架</a></li><li class="sidebarItem__DBe"><a aria-current="page" class="sidebarItemLink_mo7H sidebarItemLinkActive_I1ZP" href="/blog/page-render">浏览器渲染页面</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/js-ip-compare">JS 字符串IP地址比较大小</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/pnpm">PNPM 初识</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/vite">Vite 的介绍</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="http://schema.org/Blog"><article itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h1 class="title_f1Hy" itemprop="headline">浏览器渲染页面</h1><div class="container_mt6G margin-vert--md"><time datetime="2022-01-29T15:11:00.000Z" itemprop="datePublished">January 29, 2022</time> · <!-- -->14 min read</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://github.com/zeffon" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://github.com/zeffon.png" alt="Zeffon Wu"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://github.com/zeffon" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Zeffon Wu</span></a></div><small class="avatar__subtitle" itemprop="description">A web engineer</small></div></div></div></div></header><div id="post-content" class="markdown" itemprop="articleBody"><p>作为前端开发，更多的都是在于浏览器打交道，对于一个页面是如何渲染出来，那么我们就需要很了解浏览器的渲染机制。而在了解浏览器的渲染机制前，我们需要了解浏览器的内部结构是怎样的。</p><p>​👉 <a href="https://www.yuque.com/zeffon/blog/page-render" target="_blank" rel="noopener noreferrer">原文链接</a> 👈</p><p>本文学习自《<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=822&amp;decorateId=fa0e22c7bea94d52b2a71f2de8221e7a&amp;lgec_type=website&amp;lgec_sign=40209EF6C070714E5D2725BBDC010F63&amp;p=422291f6ffe9570fbe0aa510a5bb64d87202885e6fb5de68096ab2d0d8dd4137f73d4353e92f25f4&amp;utm_campaign=distribution#/detail/pc?id=7204" target="_blank" rel="noopener noreferrer">前端进击笔记 08</a>》和《深入了解现代浏览器系列》。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="浏览器的内部结构">浏览器的内部结构<a class="hash-link" href="#浏览器的内部结构" title="Direct link to heading">​</a></h2><p>从结构上来说，<strong>浏览器</strong> 的内部结构可以分为<strong>八个子系统</strong>：<strong>用户界面</strong>、<strong>浏览器引擎</strong>、<strong>渲染引擎</strong>、<strong>网络子系统</strong>、<strong>JavaScript 解释器</strong>、<strong>XML 解析器</strong>、<strong>显示后端</strong>、<strong>数据持久性子系统</strong>。
​</p><p>那么这八个子系统间的关系又是如何的呢？
<img loading="lazy" alt="image.png" src="/assets/images/01-29-01-6a546b04a186279d5ebf806aa096d3e8.png" width="589" height="392" class="img_ev3q"></p><p>由<strong>用户界面</strong>充当浏览器的入口，接着的是浏览器引擎，而<strong>浏览器引擎</strong>后者就是我们页面渲染出来的核心子系统 - <strong>渲染引擎</strong>，从渲染引擎与其它子系统的交互中，我们可知道<strong>页面的加载和渲染过程</strong>，离不开<strong>网络子系统</strong>、<strong>渲染引擎</strong>、<strong>JavaScript 解释器</strong>和<strong>浏览器引擎</strong>。
​</p><p>以前端开发最常使用的 <strong>Chrome</strong> 浏览器为例， <strong>Chrome</strong> 浏览器是使用多进程架构的方式来管理这些子系统。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="chrome-多进程架构">Chrome 多进程架构<a class="hash-link" href="#chrome-多进程架构" title="Direct link to heading">​</a></h2><p><strong>Chrome</strong> 浏览器采用的<strong>多进程架构</strong>，主要包括<strong>五个进程</strong>：
<img loading="lazy" alt="image.png" src="/assets/images/01-29-02-79342689c9ecf881aeb3d00e358eede3.png" width="747" height="384" class="img_ev3q"></p><ol><li><strong>浏览器进程</strong>：负责整个浏览器内行为协调，调用各个进程。。</li><li><strong>GPU 进程</strong>：该进程用于完成图像处理任务，同时还支持分解成多个进程进行处理。</li><li><strong>网络进程</strong>。主要负责页面网络资源的加载。</li><li><strong>渲染器进程</strong>：<strong>Chrome</strong> 浏览器中支持多个选项卡，其中每个选项卡在单独的渲染器进程中运行，渲染器进程主要用于控制和处理选项卡中的网站内容显示。</li><li><strong>插件进程</strong>：主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。</li></ol><p>​</p><p>除此之外，还有：负责本地 I/O 的 <strong>存储进程</strong>、负责浏览器提供给用户的 <strong>UI 进程</strong> 和负责与各种本地设备交互的 <strong>设备进程</strong>。
​</p><p>对于“在浏览器的地址栏中输入 <strong>URL</strong>，按下回车键，到浏览器渲染页面”这个过程，浏览器内部会通过<strong>浏览器进程、网络进程 </strong>和 <strong>渲染器进程</strong>，进行很多交互逻辑，最终才得以将页面内容显示在屏幕上。
​</p><p>基于这些进程，浏览器有两种可用的架构设计，一种是<strong>少进程</strong>，一种是<strong>多进程</strong>。
​</p><p><strong>少进程</strong>是指将这些进程放在一个或有限的几个进程里，也就是每个进程一个线程，这样做的好处是最大程度共享了内存空间，对设备要求较低，但问题是只要一个线程挂了都会导致整个浏览器挂掉，因此稳定性较差。
​</p><p><strong>多进程</strong>是指为每个进程（尽量）开辟一个进程空间，进程间通过 <a href="https://zh.wikipedia.org/zh-cn/%E8%A1%8C%E7%A8%8B%E9%96%93%E9%80%9A%E8%A8%8A" target="_blank" rel="noopener noreferrer"><strong>IPC 通信</strong></a>，因此任何进程挂掉都不会影响其它进程，但坏处是内存占用较大，比如浏览器 js 解析与执行引擎 V8 就要在这套架构下拷贝多份实例运行在每个进程中。
​</p><p><strong>Chrome</strong> 尽量为每个 <strong>tab</strong> 单独创建一个进程，所以我们才能在某个 <strong>tab</strong> 未响应时，从容的关闭它，而其它 <strong>tab</strong> 不会受到影响。不仅是 <strong>tab</strong> 间，一个 <strong>tab</strong> 内的 <strong>iframe</strong> 间也会创建独立的进程，这样做是为了保护网站的安全性。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="浏览器中页面的渲染过程">浏览器中页面的渲染过程<a class="hash-link" href="#浏览器中页面的渲染过程" title="Direct link to heading">​</a></h2><p>首先我们将浏览器中页面的<strong>渲染过程</strong>分为两部分。</p><ol><li>页面导航：用户输入 <strong>URL</strong>，<strong>浏览器进程</strong>进行请求和准备处理。</li><li>页面渲染：获取到相关资源后，<strong>渲染器进程</strong>负责选项卡内部的渲染处理。</li></ol><p>​</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="页面导航过程">页面导航过程<a class="hash-link" href="#页面导航过程" title="Direct link to heading">​</a></h3><p>当用户在地址栏中输入内容时，浏览器内部会进行以下处理。</p><ol><li>首先<strong>浏览器进程</strong>的 <strong>UI 线程</strong>会进行处理：如果是 <strong>URI</strong>，则会发起网络请求来获取网站内容；如果不是，则进入搜索引擎。</li><li>如果需要发起网络请求，请求过程由<strong>网络线程</strong>来完成。<strong>HTTP</strong> 请求响应如果是 <strong>HTML</strong> 文件，则将数据传递到<strong>渲染器进程</strong>；如果是其他文件则意味着这是下载请求，此时会将数据传递到<strong>下载管理器</strong>。</li><li>如果请求响应为 <strong>HTML</strong> 内容，此时浏览器应导航到请求站点，<strong>网络线程</strong> 便通知 <strong>UI 线程</strong> 数据准备就绪。</li><li>接下来，<strong>UI 线程</strong>会寻找一个<strong>渲染器进程</strong>来进行网页渲染。当数据和<strong>渲染器进程</strong>都准备好后，<strong>HTML</strong> 数据通过 <strong>IPC</strong> 从<strong>浏览器进程</strong>传递到<strong>渲染器进程</strong>中。</li><li><strong>渲染器进程</strong>接收 <strong>HTML</strong> 数据后，将开始加载资源并渲染页面。</li><li><strong>渲染器进程</strong>完成渲染后，通过 <strong>IPC</strong> 通知浏览器进程页面已加载。</li></ol><p>​</p><p>以上是用户在地址栏输入网站地址，到页面开始渲染的整体过程。为了方便理解，我帮你梳理了一个流程图：
<img loading="lazy" alt="image.png" src="/assets/images/01-29-03-709fe942b16ba87fcc54540b4f224765.png" width="969" height="644" class="img_ev3q"></p><p>如果当前页面跳转到其他网站，浏览器将调用一个单独的 <strong>渲染器进程</strong> 来处理新导航，同时保留当前<strong>渲染器进程</strong>来处理像<strong>unload</strong>这类事件。
​</p><p>在上面的过程中可以看到，页面导航主要依赖<strong>浏览器进程</strong>。其中，上述过程中的 <strong>步骤 6 </strong>便是页面的渲染部分，该过程同样依赖<strong>渲染器进程</strong>，我们一起来看看。
​</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="页面渲染过程">页面渲染过程<a class="hash-link" href="#页面渲染过程" title="Direct link to heading">​</a></h3><p>​<strong>渲染器进程</strong> 负责选项卡内部发生的所有事情，它的核心工作是将 <strong>HTML</strong>、<strong>CSS</strong> 和 <strong>JavaScript</strong> 转换为可交互的页面。
​</p><p>整体上，<strong>渲染器进程</strong> 渲染页面的流程如下四个步骤</p><ol><li>解析(<strong>Parser</strong>)：解析<strong> HTML/CSS/JavaScript </strong>代码。</li><li>布局(<strong>Layout</strong>)：定位坐标和大小、是否换行、各种<strong>position/overflow/z-index</strong>属性等计算。</li><li>绘制(<strong>Paint</strong>)：判断元素渲染层级顺序。</li><li>光栅化(<strong>Raster</strong>)：将计算后的信息转换为屏幕上的像素。</li></ol><h4 class="anchor anchorWithStickyNavbar_LWe7" id="解析">解析<a class="hash-link" href="#解析" title="Direct link to heading">​</a></h4><p><strong>渲染器进程</strong>的主线程会解析以下内容：</p><ul><li>解析 <strong>HTML</strong> 内容，产生一个 <strong>DOM 节点树</strong>；</li><li>解析 <strong>CSS</strong>，产生<strong> CSS 规则树</strong>；</li><li>解析 <strong>Javascript</strong> 脚本，由于 <strong>Javascript</strong> 脚本可以通过 <strong>DOM API</strong> 和 <strong>CSSOM API</strong> 来操作 <strong>DOM 节点树</strong> 和 <strong>CSS 规则树</strong>，因此该过程中会等待 <strong>JavaScript</strong> 运行完成才继续解析 <strong>HTML</strong>。</li></ul><p><img loading="lazy" alt="image.png" src="/assets/images/01-29-04-6a946a53c40adbee184b852629a8a6ea.png" width="750" height="272" class="img_ev3q"></p><p>解析完成后，我们得到了 <strong>DOM 节点树</strong> 和 <strong>CSS 规则树</strong>，布局过程中便是通过 <strong>DOM 节点树</strong> 和 <strong>CSS 规则树</strong> 来<strong>构造渲染树</strong>（<strong>Render Tree</strong>）。
​</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="布局">布局<a class="hash-link" href="#布局" title="Direct link to heading">​</a></h4><p>通过<strong>解析</strong>之后，<strong>渲染器进程</strong>知道<strong>每个节点</strong>的结构和样式，但如果需要渲染页面，浏览器还需要进行<strong>布局</strong>，<strong>布局过程</strong>便是我们常说的<strong>渲染树</strong>的创建过程。
​</p><p>在这个过程中，像<strong>header</strong>或<strong>display:none</strong>的元素，它们会存在 <strong>DOM 节点树</strong>中，但不会被添加到<strong>渲染树</strong>里。
<img loading="lazy" alt="image.png" src="/assets/images/01-29-05-faa18942a89d2fa4d564d50e3c2cdc26.png" width="750" height="375" class="img_ev3q"></p><p>布局完成后，将会进入<strong>绘制</strong>环节。
​</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="绘制">绘制<a class="hash-link" href="#绘制" title="Direct link to heading">​</a></h4><p>在<strong>绘制</strong>步骤中，<strong>渲染器主线程</strong>会遍历<strong>渲染树</strong>来创建<strong>绘制</strong>记录。
​</p><p>需要注意的是，如果<strong>渲染树</strong>发生了改变，则<strong>渲染器</strong>会触发<strong>重绘</strong>（<strong>Repaint</strong>）和<strong>重排</strong>（<strong>Reflow</strong>）。</p><ul><li><strong>重绘</strong>：屏幕的一部分要重画，比如某个 <strong>CSS</strong> 的背景色变了，但是元素的<strong>几何尺寸</strong>没有变。</li><li><strong>重排</strong>：元素的<strong>几何尺寸</strong>变了（渲染树的一部分或全部发生了变化），需要重新验证并计算<strong>渲染树</strong>。</li></ul><p>​</p><p>为了不对每个小的变化都进行完整的布局计算，<strong>渲染器</strong>会将更改的元素和它的子元素进行<strong>脏位标记</strong>，表示该元素需要重新布局。其中，全局样式更改会触发<strong>全局布局</strong>，部分样式或元素更改会触发<strong>增量布局</strong>，增量布局是异步完成的，全局布局则会同步触发。
​</p><p><strong>重排</strong>需要涉及变更的所有的结点<strong>几何尺寸</strong>和<strong>位置</strong>，成本比<strong>重绘</strong>的成本高得多的多。所以我们要注意以避免频繁地进行增加、删除、修改 <strong>DOM</strong> 结点、移动 <strong>DOM</strong> 的位置、<strong>Resize</strong> 窗口、滚动等操作，因为这些操作可能会导致性能降低。
​</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="光栅化">光栅化<a class="hash-link" href="#光栅化" title="Direct link to heading">​</a></h4><p>通过<strong>解析</strong>、<strong>布局</strong>和<strong>绘制</strong>过程，浏览器获得了文档的结构、每个元素的样式、绘制顺序等信息。将这些<strong>信息转换为屏幕上的像素</strong>，这个过程被称为<strong>光栅化</strong>。
​</p><p><strong>光栅化</strong>可以被 <strong>GPU</strong> 加速，<strong>光栅化</strong>后的位图会被存储在 <strong>GPU</strong> 内存中。根据前面介绍的<strong>渲染流程</strong>，当页面布局变更了会触发<strong>重绘</strong>和<strong>重排</strong>，还需要重新进行<strong>光栅化</strong>。此时如果页面中有动画，则主线程中过多的计算任务很可能会影响动画的性能。
​</p><p>因此，现代的浏览器通常使用合成的方式，将页面的各个部分分成若干层，分别对其进行<strong>栅格化</strong>（将它们分割成了不同的瓦片），并通过合成器线程进行页面的合成。
<img loading="lazy" alt="image.png" src="/assets/images/01-29-06-1b513ab388ce13c7c7006b2be5f8ce85.png" width="677" height="386" class="img_ev3q"></p><p>合成过程如下：</p><ol><li>当主线程创建了合成层并确定了绘制顺序，便将这些信息提交给合成线程；</li><li>合成器线程将每个图层栅格化，然后将每个图块发送给光栅线程；</li><li>光栅线程栅格化每个瓦片，并将它们存储在 <strong>GPU</strong> 内存中；</li><li>合成器线程通过 <strong>IPC</strong> 提交给浏览器进程，这些合成器帧被发送到 <strong>GPU</strong> 进程处理，并显示在屏幕上。</li></ol><p><img loading="lazy" alt="image.png" src="/assets/images/01-29-07-1a059f8027eb8c541620c4afa2632da1.png" width="1252" height="427" class="img_ev3q"></p><p>合成的真正目的是，在移动合成层的时候不用重新光栅化。因为有了合成器线程，页面才可以独立于主线程进行流畅的滚动。
​</p><p>到这里，页面才真正渲染到屏幕上。</p></div><footer class="row docusaurus-mt-lg blogPostFooterDetailsFull_mRVl"><div class="col"><b>Tags:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/js">js</a></li></ul></div><div class="col margin-top--sm"><a href="https://github.com/zeffon/zeffon.github.io/blob/master/blog/2022/2022-01-29-page-render.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Blog post page navigation"><a class="pagination-nav__link pagination-nav__link--prev" href="/blog/koa-web"><div class="pagination-nav__sublabel">Newer Post</div><div class="pagination-nav__label">使用 TypeScript 构建 Koa2 RESTful API 最佳的脚手架</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/blog/js-ip-compare"><div class="pagination-nav__sublabel">Older Post</div><div class="pagination-nav__label">JS 字符串IP地址比较大小</div></a></nav></main><div class="col col--2"><div class="tableOfContents_bqdL thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#浏览器的内部结构" class="table-of-contents__link toc-highlight">浏览器的内部结构</a></li><li><a href="#chrome-多进程架构" class="table-of-contents__link toc-highlight">Chrome 多进程架构</a></li><li><a href="#浏览器中页面的渲染过程" class="table-of-contents__link toc-highlight">浏览器中页面的渲染过程</a><ul><li><a href="#页面导航过程" class="table-of-contents__link toc-highlight">页面导航过程</a></li><li><a href="#页面渲染过程" class="table-of-contents__link toc-highlight">页面渲染过程</a></li></ul></li></ul></div></div></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/docs/intro">文档</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="mailto:ZeffonWu@gmail.com" target="_blank" rel="noopener noreferrer" class="footer__link-item">ZeffonWu@gmail.com<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://www.yuque.com/zeffon/blog" target="_blank" rel="noopener noreferrer" class="footer__link-item">语雀<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022 Zeffon, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.77cd9461.js"></script>
<script src="/assets/js/main.d08d51d4.js"></script>
</body>
</html>